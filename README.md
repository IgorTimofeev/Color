
О библиотеке
======
Color - библиотека для работы с цветом. Она позволяет осуществлять экструзию и упаковку цветовых каналов, преобразовывать цветовую модель RGB в HSB и наоборот, осуществлять альфа-блендинг, генерировать цветовые переходы и конвертировать цвет в 8-битный формат для палитры OpenComputers.

Установка
======

Исходный код доступен по ссылке: https://github.com/IgorTimofeev/OpenComputers/blob/master/lib/color.lua

Для загрузки на компьютер вы можете воспользоваться стандартной утилитой **wget**:

    wget https://raw.githubusercontent.com/IgorTimofeev/OpenComputers/master/lib/color.lua -f

Работа с цветовыми каналами
======

color.**RGBToInteger**( red, green, blue ): *int* IntegerColor
-----------------------------------------------------------
| Тип | Аргумент | Описание |
| ------ | ------ | ------ |
| *byte* **[0; 255]** | red | Красный цветовой канал |
| *byte* **[0; 255]** | green | Зеленый цветовой канал |
| *byte* **[0; 255]** | blue | Синий цветовой канал |

Метод упаковывает три цветовых канала и возвращает 24-битную целочисленную переменную

color.**integerToRGB**( IntegerColor ): *byte* red, *byte* green, *byte* blue
-----------------------------------------------------------
| Тип | Аргумент | Описание |
| ------ | ------ | ------ |
| *int*  | IntegerColor | Цвет в формате 0xRRGGBB |

Метод извлекает и возвращает три цветовых канала из 24-битной целочисленной переменной. Значения возвращаемых данных находятся в диапазоне [0; 255]

Обработка цвета
======

color.**blend**( firstColor, secondColor, secondColorTransparency ): *int* blendedColor
-----------------------------------------------------------
| Тип | Аргумент | Описание |
| ------ | ------ | ------ |
| *int* | firstColor | Первый цвет |
| *int* | secondColor | Второй цвет |
| *float* **[0.0; 1.0]** | secondColorTransparency | Прозрачность второго цвета при наложении |

Метод накладывает второй цвет на первый, учитывая прозрачность второго. К примеру, если на красный цвет 0xFF0000 наложить черный цвет 0x000000 с прозрачностью 0.5, то в результате получится цвет 0x7F0000, то есть, темно-красный

color.**transition**( firstColor, secondColor, position ): *int* transitionColor
-----------------------------------------------------------
| Тип | Аргумент | Описание |
| ------ | ------ | ------ |
| *int* | firstColor | Первый цвет |
| *int* | secondColor | Второй цвет |
| *float* **[0.0; 1.0]** | position | Позиция точки перехода от первого цвета ко второму |

Метод генерирует переходный цвет между первым и вторым цветом, основываясь на аргументе transition, где значение 0.0 эквивалентно первому цвету, а 1.0 - второму. К примеру, если осуществить переход от черного цвета 0x000000 к белому 0xFFFFFF с позицией перехода 0.5, то в результате получится цвет 0x7F7F7F, то есть, серый.

Преобразование цветовых моделей
======

color.**RGBToHSB**( red, green, blue ): *int* hue, *float* saturation, *float* brightness
-----------------------------------------------------------
| Тип | Аргумент | Описание |
| ------ | ------ | ------ |
| *byte* **[0; 255]** | red | Красный цветовой канал |
| *byte* **[0; 255]** | green | Зеленый цветовой канал |
| *byte* **[0; 255]** | blue | Синий цветовой канал |

Метод преобразует три цветовых канала цветовой модели RGB в цветовую модель HSB (HSV) и возвращает соответствующий результат. Значения возвращаемых данных *hue* находится в диапазоне [0; 360], а *saturation* и *brightness* - в диапазоне [0.0; 1.0].

Для удобства также имеется метод color.**integerToHSB**(*int* integerColor): *int* hue, *float* saturation, *float* brightness

color.**HSBToRGB**( hue, saturation, brightness ): *byte* red, *byte* green, *byte* blue
-----------------------------------------------------------
| Тип | Аргумент | Описание |
| ------ | ------ | ------ |
| *int* **[0; 360]** | hue | Оттенок |
| *float* **[0.0; 1.0]** | saturation | Насыщенность |
| *float* **[0.0; 1.0]** | brightness | Яркость |

Метод преобразует параметры цветовой модели HSB (HSV) в три цветовых канала модели RGB и возвращает соответствующий результат.

Для удобства также имеется метод color.**HSBToInteger**(*int* hue, *float* saturation, *float* brightness): *int* integerColor

Компрессия цвета
======

color.**to8Bit**( 24BitColor ): *byte* 8BitColor
-----------------------------------------------------------
| Тип | Аргумент | Описание |
| ------ | ------ | ------ |
| *int* | 24BitColor | Цвет в формате 0xRRGGBB  |

Метод обращается к 256-цветной палитре OpenComputers и возвращает индекс цвета, наилучшим образом соответствующего переданному значению, используя тот же метод поиска, что и в gpu.**setBackground**(color). В результате возвращается переменная в диапазоне [0; 255], которая может быть использована для записи в бинарный файл, позволяя экономить память. Обращаю внимание, что метод медленный, и не подходит для отрисовки графики на экране.

color.**to24Bit**( 8BitColor ): *int* 24BitColor
-----------------------------------------------------------
| Тип | Аргумент | Описание |
| ------ | ------ | ------ |
| *int* | 8BitColor | Индекс палитры OpenComputers  |

Метод позволяет осуществить обратное преобразование 8-битного индекса, созданного методом color.**to8Bit**.
